# C++类型转换

## background

C++语法允许四种不同类型的类型转换来满足开发者的不同需求。每种转换类型执行独特的转换操作，引发了非平凡的安全问题。在接下来的内容中，我们提供了每种转换类型的详细信息，特别关注其在类型混淆问题方面的安全性。

图1中的示例展示了使用static_cast的转换，但C++中还有其他类型的转换，其细节对于本文非常重要。我们关注的其他转换类型包括dynamic_cast、reinterpret_cast和C风格的类型转换。

**Static Cast. static_cast**将类型A的对象转换为类型B的对象。该检查仅在编译时执行，不进行运行时检查。由于此检查的静态性质，不考虑对象的运行时类型，检查仅限于检查两种类型是否兼容，即从表达式的类型到类型之间存在涉及向上转型和/或向下转型的类型层次结构路径。

虽然不会产生任何性能开销，但static_cast的安全性保证有限。因此，程序员需要确保使用正确类型的对象，例如保证向下转型的对象实际上是派生类型的对象。实际上，由于在编译时确定此类兼容性是有挑战性的，这导致了一个不幸的事实，即类型混淆在现代C++程序中占据了主导地位的漏洞 [23]。

**Dynamic Cast. dynamic_cast**可以在同一类层次结构中安全地转换类之间的类型。与static_cast仅执行编译时检查不同，dynamic_cast还使用重量级元数据——运行时类型信息（RTTI）执行额外的运行时检查。由于通常无法静态确定对象的动态运行时类型，dynamic_cast必须利用运行时类型信息，例如RTTI。RTTI编码了所有与类型相关的信息，并且编译器为每种类型生成此RTTI，使得每种类型在编译的二进制文件中有其专用的RTTI条目。RTTI条目实际上形成一个递归结构，每个RTTI条目指向另一个RTTI条目，以表示类层次结构。编译器还在每个虚函数表的末尾附加对RTTI条目的引用，以便在运行时使用任何指向对象的虚地址指针来检索RTTI条目。换句话说，由于对象的第一个字段通常填充有一个虚函数表指针，dynamic_cast可以使用虚函数表指针找到给定对象地址的RTTI条目。定位相应的RTTI条目后，dynamic_cast开始递归遍历RTTI以验证类型转换的正确性（即类型是否兼容）。如果expression的类型和目标类型之间存在类型层次结构路径，则类型是兼容的。只要expression的类型是type的后代（向上转型），类型也可以是兼容的。当type是expression指向的对象的确切类型时，类型也可以是兼容的。如果转换是不正确的（即expression的类型和type不兼容），则转换失败有两种方式：



## 总结

### 1. Static Cast. static_cast

检查时间：编译时检查，运行时不检查

检查范围：不检查对象运行时的类型，只检查表达式中两种类型是否兼容

性能开销：无

安全保证：弱



