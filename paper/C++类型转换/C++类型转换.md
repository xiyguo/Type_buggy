# C++类型转换

## background

C++语法允许四种不同类型的类型转换来满足开发者的不同需求。每种转换类型执行独特的转换操作，引发了非平凡的安全问题。在接下来的内容中，我们提供了每种转换类型的详细信息，特别关注其在类型混淆问题方面的安全性。

图1中的示例展示了使用static_cast的转换，但C++中还有其他类型的转换，其细节对于本文非常重要。我们关注的其他转换类型包括dynamic_cast、reinterpret_cast和C风格的类型转换。

**Static Cast. static_cast**将类型A的对象转换为类型B的对象。该检查仅在编译时执行，不进行运行时检查。由于此检查的静态性质，不考虑对象的运行时类型，检查仅限于检查两种类型是否兼容，即**从表达式的类型到类型之间存在涉及向上转型和/或向下转型的类型层次结构路径**。

虽然不会产生任何性能开销，但static_cast的安全性保证有限。因此，程序员需要确保使用正确类型的对象，例如保证向下转型的对象实际上是派生类型的对象。实际上，由于在编译时确定此类兼容性是有挑战性的，这导致了一个不幸的事实，即类型混淆在现代C++程序中占据了主导地位的漏洞 [23]。

**Dynamic Cast. dynamic_cast**可以在同一类层次结构中安全地转换类之间的类型。与static_cast仅执行编译时检查不同，dynamic_cast还使用重量级元数据——运行时类型信息（RTTI）执行额外的运行时检查。由于通常无法静态确定对象的动态运行时类型，dynamic_cast必须利用运行时类型信息，例如RTTI。RTTI编码了所有与类型相关的信息，并且编译器为每种类型生成此RTTI，使得每种类型在编译的二进制文件中有其专用的RTTI条目。RTTI条目实际上形成一个递归结构，每个RTTI条目指向另一个RTTI条目，以表示类层次结构。编译器还在每个虚函数表的末尾附加对RTTI条目的引用，以便在运行时使用任何指向对象的虚地址指针来检索RTTI条目。换句话说，由于对象的第一个字段通常填充有一个虚函数表指针，dynamic_cast可以使用虚函数表指针找到给定对象地址的RTTI条目。定位相应的RTTI条目后，dynamic_cast开始递归遍历RTTI以验证类型转换的正确性（即类型是否兼容）。**如果表达式的类型和目标类型之间存在类型层次结构路径，则类型是兼容的。**只要expression的类型是type的后代（向上转型），类型也可以是兼容的。当type是expression指向的对象的确切类型时，类型也可以是兼容的。如果转换是不正确的（即expression的类型和type不兼容），则转换失败有两种方式：

* 如果type是指针类型，dynamic_cast返回NULL。 

* 如果type是引用类型，dynamic_cast会抛出一个预定义的异常（即std::bad_cast）

由于dynamic_cast的设计，其使用严格限制于多态对象。如前所述，dynamic_cast依赖于虚函数表来定位RTTI，但虚函数表仅存在于多态对象中。请注意，鉴于这些限制，dynamic_cast只能用于多态类型。因此，如果在非多态类型上使用dynamic_cast，编译器将生成编译时错误。请注意，仍然可能发生运行时错误。

**reinterpret_cast**用于在任意两种（可能不兼容的）类型之间进行转换。它指示编译器重新解释转换对象的底层位模式。由于它既不创建副本也不执行任何运行时检查，reinterpret_cast总是不会产生额外的开销。从安全角度来看，程序员需要确保reinterpret_cast的正确性，类似于static_cast的情况。由于reinterpret_cast只改变对象的类型，它只会返回相同的地址。这种行为可能会对多态类或具有多重继承的类造成问题。对于多态类，reinterpret_cast会返回一个指向对象的潜在错误vtable指针，因为reinterpret_cast不会改变对象的内存。如果对象使用多重继承，则指向基类的指针可能具有错误的值（不是指向对象本身的指针）[5]。但是，如果确切的源对象类型信息是已知的，那么可以使用reinterpret_cast来：（1）高效地构造对象而不执行构造函数（重用相同类型的旧对象），以及（2）在函数返回避免指向一个对象时恢复实际类型。

## 总结



### static_cast

`static_cast`是C++中的一种类型转换操作符，用于在编译时进行类型转换。它可以在内置的数据类型之间互相转换，也可以在类之间进行转换，但对于类的转换，只能在有联系的指针类型之间进行转换。

使用`static_cast`时，编译器会尝试进行类型转换，但在进行转换之前，它不会进行运行时检查。因此，使用`static_cast`需要程序员保证转换的安全性，否则可能会导致未定义的行为。

`static_cast`的使用场景包括但不限于以下几种：

1. 基本数据类型的转换：`static_cast`可以用于基本数据类型之间的类型转换，例如将整数转换为浮点数或者将浮点数转换为整数。

```C++
int x = 10;
double y = static_cast<double>(x);
```

2. 显式类型转换：当编译器无法自动进行类型转换时，可以使用`static_cast`进行显式转换。

```C++
double d = 3.14;
int i = static_cast<int>(d); // 显式将 double 转换为 int
```

3. 父子类指针的转换：当需要将基类指针转换为派生类指针时，可以使用`static_cast`。但请注意，这种转换只有在确保基类指针实际指向派生类对象时才安全，否则可能会导致未定义的行为。

```C++
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {};

Base* basePtr = new Derived;
Derived* derivedPtr = static_cast<Derived*>(basePtr);
```

4. 类型宽化或缩小：`static_cast`可以用于将类型的范围缩小或扩大。

```C++
int i = 10;
char c = static_cast<char>(i); // 将 int 缩小为 char
```

需要注意的是，虽然`static_cast`在某些情况下可以实现类型转换，但对于某些情况，如多态类型之间的转换，建议使用`dynamic_cast`，它会在运行时检查转换的有效性，并返回空指针或抛出异常来保证转换的安全性。另外，在进行类型转换时，始终要谨慎考虑转换的正确性和安全性，避免引入潜在的错误和问题。

### const_cast

`const_cast`是C++中的一种类型转换操作符，用于<u>去除指针或引用类型</u>的`const`或`volatile`修饰符。它可以在编译时进行类型转换，用于转换掉对象的常量性或易变性。但需要注意，使用`const_cast`要非常谨慎，因为它可能会导致程序的行为变得未定义，如果不正确使用，可能引入潜在的错误。

`const_cast`的语法如下：

```C++
const_cast<new_type>(expression)
```

其中，`new_type`是欲转换的指针或引用的类型，`expression`是需要去除`const`或`volatile`修饰符的表达式。

使用场景包括但不限于以下几种：

1. 修改常量对象：当我们需要修改一个原本被声明为`const`的对象时，可以使用`const_cast`去除`const`修饰符，从而修改对象的值。但这仅适用于原始对象不是真正常量的情况，即其声明不是`const`，但通过其他方式被视为常量。

```C++
const int num = 10; // 声明为const
int* ptr = const_cast<int*>(&num);
*ptr = 20; // 修改num的值，但会导致未定义行为
```

2. 在常量成员函数中修改成员变量：在常量成员函数中，成员变量默认被视为`const`，不能直接修改。但在某些特殊情况下，我们可能需要在常量成员函数中修改成员变量，这时可以使用`const_cast`去除成员变量的`const`修饰符。

```C++
class MyClass {
public:
    void print() const {
        const_cast<MyClass*>(this)->value = 10; // 修改成员变量
    }

private:
    int value;
};
```

需要强调的是，使用`const_cast`是一种非常危险的操作，它有可能导致未定义行为，特别是当原始对象实际上是真正的常量时。因此，在使用`const_cast`时，务必确保转换的目标对象并非真正的常量，并且非常了解代码的语义和实现细节，以避免引入潜在的错误。如果能够避免使用`const_cast`，那么就应该尽量避免，而是选择更安全和更合理的方式来处理常量性或易变性的问题。

### dynamic_cast

`dynamic_cast`是C++中一种用于在继承层次结构中进行安全类型转换的运算符。它可以在运行时进行类型检查，判断是否可以安全地将一个指向基类对象的指针或引用转换为指向派生类对象的指针或引用。`dynamic_cast`主要用于处理多态对象（即带有虚函数的类）。

使用场景：

1. 多态对象的向下转型：当我们有一个指向基类的指针或引用，并且需要在运行时确定它指向的是否是派生类，然后再进行相应的操作时，可以使用`dynamic_cast`来进行向下转型。如果转型成功，即指向的确实是派生类对象，那么转型结果是有效的，可以安全地使用；如果转型失败，即指向的不是派生类对象，那么转型结果将返回空指针（对于指针类型）或抛出`std::bad_cast`异常（对于引用类型），以防止错误的访问派生类的成员。
2. 判断对象的类型：在某些情况下，我们需要在运行时判断一个对象的实际类型是哪个类。例如，在处理基类对象的容器（如容器或数组）中，我们可能需要区分每个对象的具体类型以执行不同的操作。通过使用`dynamic_cast`，我们可以在运行时检查对象的实际类型，并根据不同的类型进行处理。

使用示例：

```
cppCopy code
#include <iostream>

class Base {
public:
    virtual void print() {
        std::cout << "Base" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();

    // 将基类指针转换为派生类指针
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr) {
        // 转换成功，指向的是Derived对象
        derivedPtr->print(); // 输出：Derived
    } else {
        // 转换失败，指向的不是Derived对象
        std::cout << "Conversion failed." << std::endl;
    }

    delete basePtr;
    return 0;
}
```

需要注意的是，`dynamic_cast`只能用于处理带有虚函数的类，因为在运行时需要借助虚函数表（vtable）来进行类型检查。此外，对于非多态类（没有虚函数的类），编译器会在编译时就完成类型检查，因此不需要使用`dynamic_cast`。另外，在使用`dynamic_cast`时，确保指针或引用指向的对象是有效的，否则会导致未定义行为

### reinterpret_cast

`reinterpret_cast` 是 C++ 中的一种类型转换运算符，它可以将一个指针或引用转换为一个完全不同类型的指针或引用，甚至可以将整数类型转换为指针类型或者将指针类型转换为整数类型。它是一种非常强制性的转换，通常应该谨慎使用，因为它可以绕过类型系统，可能导致未定义行为和不安全的操作。

`reinterpret_cast` 的使用场景有限，因为它不会执行任何类型检查或转换操作，只是简单地将指针或引用的二进制表示重新解释为另一种类型。一般来说，`reinterpret_cast` 应该只用于以下情况：

1. 在某些特定底层编程场景中，可能需要将指针转换为一个完全不同类型的指针，例如将 `void*` 指针转换为其他类型的指针，或者在某些底层数据结构中进行指针运算。
2. 在一些特殊的硬件相关操作中，可能需要将整数类型的数据转换为指针类型或者将指针类型转换为整数类型，但这种情况非常罕见，而且应该小心谨慎，确保没有导致潜在的安全问题。

总的来说，`reinterpret_cast` 应该被视为一种危险的转换操作，除非在非常特殊的情况下，确切知道转换的结果并且明确知道没有安全问题，否则不应该随意使用。在一般情况下，应该优先考虑使用 `static_cast` 或 `dynamic_cast`，它们能够提供更安全的类型转换和类型检查。

### dynamic_cast和static_cast的区别

`dynamic_cast`和`static_cast`都是C++中的类型转换运算符，用于进行类型转换，但它们在使用场景和行为上有一些区别。

1. `dynamic_cast`：
   - 主要用于在继承层次结构中进行安全的向下转型（从基类指针/引用到派生类指针/引用）。
   - 在运行时进行类型检查，可以动态确定是否可以安全地将基类指针或引用转换为派生类指针或引用。
   - 如果转型失败（即指向的不是派生类对象），转型结果将返回空指针（对于指针类型）或抛出`std::bad_cast`异常（对于引用类型）。
   - 主要用于处理多态对象，即带有虚函数的类。
2. `static_cast`：
   - 主要用于执行编译时的类型转换，进行基本数据类型之间的转换，或者进行不涉及继承层次结构的类型转换。
   - 不进行运行时类型检查，是一种较为简单的类型转换，不考虑继承关系。
   - 可以在内置数据类型之间相互转换，也可以在具有继承关系的类之间进行上行转型（从派生类指针/引用到基类指针/引用），但不能进行向下转型（从基类指针/引用到派生类指针/引用）。
   - 用于进行非多态类的类型转换，例如将`int`类型转换为`double`类型，或者进行指针类型的转换，但需要确保转换是合法的。

使用区别：

- 如果要进行多态类的类型转换（继承层次结构中的向下转型），应使用`dynamic_cast`，以便在运行时进行类型检查，避免出现未定义行为。
- 如果需要进行非多态类的类型转换或者基本数据类型之间的转换，可以使用`static_cast`。但要注意，在进行指针类型转换时，`static_cast`只能进行上行转型，不能进行向下转型。
