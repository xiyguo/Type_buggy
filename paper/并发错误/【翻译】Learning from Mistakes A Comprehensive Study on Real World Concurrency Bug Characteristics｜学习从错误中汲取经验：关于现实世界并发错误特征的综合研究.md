# Learning from Mistakes A Comprehensive Study on Real World Concurrency Bug Characteristics｜学习从错误中汲取经验：关于现实世界并发错误特征的综合研究

## Abstract

多核硬件的实际存在使得并发程序变得无处不在。不幸的是，编写正确的并发程序是困难的。解决这个挑战需要在多个方向上取得进展，包括并发错误检测、并发程序测试、并发编程模型设计等。在所有这些方向上设计有效的技术都将从对现实世界并发错误特征的深入了解中受益。

本文提供了我们所知的第一份综合的现实世界并发错误特征研究。具体而言，我们仔细研究了来自4个代表性的开源服务器和客户端应用程序（MySQL、Apache、Mozilla和OpenOffice）中随机选择的105个现实世界并发错误的模式、表现和修复策略。我们的研究揭示了一些有趣的发现，并为并发错误检测、测试和并发编程语言设计提供了有用的指导。

根据我们目前的了解，本文提供了第一份综合的现实世界并发错误特征研究。具体来说，我们仔细研究了来自4个代表性开源服务器和客户端应用程序（MySQL、Apache、Mozilla和OpenOffice）中随机选择的105个现实世界并发错误的模式、表现和修复策略。我们的研究揭示了一些有趣的发现，并为并发错误检测、测试和并发编程语言设计提供了有用的指导。我们的一些发现如下：

（1）约三分之一的非死锁并发错误是由于**违反程序员的顺序意图**造成的，这可能无法通过像锁和事务内存这样的同步机制轻易表达出来；

（2）约34%的非死锁并发错误**涉及多个变量**，这在现有的错误检测工具中没有得到很好的解决；

（3）约92%的并发错误可以通过**强制执行不超过4次内存访问之间的特定顺序**来可靠触发。这表明测试并发程序可以针对**探索每个小组内存访问之间的可能顺序**，而不是所有内存访问之间的顺序；

（4）约73%的非死锁并发错误**不能简单地通过添加或更改锁来修复**，而且很多修复措施在第一次尝试时并不正确，这表明程序员推理并发执行的困难性。

* 分类和主题描述：D.2.5 [软件工程]: 测试和调试；B.8.1 [硬件]: 性能和可靠性 - 可靠性、测试和容错性

* 常见术语：语言、可靠性

* 关键词：并发程序、并发错误、错误特征

## 1. Introduction

### 1.1 Motivation

由于多核硬件的实际存在，并发程序正变得普遍。如今，不仅高端服务器，而且桌面机器也需要并发程序来充分利用它们的多核硬件。结果是，并发编程的困难正冲击着整个软件开发社区，而不仅仅是少数精英。编写高质量的并发程序变得至关重要。不幸的是，编写正确的并发程序是困难的。大多数程序员以顺序方式思考，因此在编写并发程序时容易犯错误。更糟糕的是，并发程序的臭名昭著的非确定性使得在交互式诊断期间难以重现并发错误。解决上述挑战将需要从多个相关方向的努力，包括以下列出的方向，所有这些方向在过去几年中取得了一些进展，但仍存在许多未解决的问题。

**（1）并发错误检测。**大多数以前的并发错误检测研究都集中在检测数据竞争错误[7,10,31,33,37,42]和死锁错误[3,10,37]上。数据竞争发生在当两个相冲突的访问对同一个共享变量进行执行时，没有适当的同步措施，例如没有受到共同的锁的保护。死锁发生在当两个或多个操作循环等待彼此释放所获取的资源时（例如锁）。最近，也提出了几种方法来检测违反原子性的错误[12,23,41]，这是由于并发执行意外违反了某个代码区域的原子性而引起的。

尽管以前的工作已经提出了有效的方法来检测某些类型的并发错误，但仍然远未提供完整的解决方案。特别是，在并发错误检测方面还存在一些未解决的问题：（i）现有的错误检测工具能否检测出所有现实世界的并发错误？具体而言，现实世界中存在哪些类型的并发错误？是否有任何类型的错误尚未被现有工作解决？此外，现有工具关于并发错误的假设是否有效？例如，大多数以前的竞争检测和许多原子性错误检测技术都专注于对单个变量的访问之间的同步。这种单变量假设会漏掉多少并发错误？（ii）现有工具在诊断和修复它们所检测到的现实世界并发错误方面有多大帮助？例如，许多并发错误检测工具会提醒程序员一些相冲突的访问没有受到相同锁的保护。这样的信息可以帮助程序员添加或更改锁操作。然而，在现实世界中，通过添加或更改锁操作有多常修复真实的并发错误？更普遍地说，程序员如何修复现实世界的并发错误，他们需要什么样的信息？

**（2）并发程序测试和模型检查测试是软件开发中的常见实践。**它是在发布之前暴露软件错误的关键步骤。现有的测试技术主要关注程序的顺序方面，例如语句、分支等，并且不能有效地解决并发程序的并发方面，如多线程（或多进程）的交错[28]。并发测试的主要挑战是并发程序的指数级交错空间。暴露并发错误不仅需要一个能暴露错误的输入，还需要一个能触发错误的执行交错。因此，为了实现对并发程序的完整测试覆盖，测试需要涵盖每个输入测试用例的所有可能交错[39]，这在实践中是不可行的。

为了应对上述挑战，关于并发测试的一个未解决问题是：我们是否可以选择性地测试一小部分代表性的交错，并且仍然暴露大多数并发错误？受到这个问题的启发，先前的研究项目（如ConTest项目[4,9]）提出了一些方法来扰乱程序执行并通过在每个同步点之后注入人为延迟来强制产生特定的交错。虽然这是一个有启发性的尝试，但无论是从定量还是定性的角度来看，目前仍不清楚这些启发式方法能够暴露多少比例的并发错误。

最终，为并发程序设计实用有效的测试用例需要对现实世界并发错误的表现条件有一个良好的理解。也就是说，我们需要知道在程序输入之外触发并发错误所需的条件是什么。具体来说，通常在现实世界的并发错误表现中涉及多少个线程、多少个变量和多少次访问？

在并发程序的软件验证和模型检查中也遇到类似的问题[13,28,34]。对现实世界并发错误表现的更好理解可以帮助模型检查优先考虑程序状态，并减轻状态爆炸问题。

**（3）并发编程语言设计良好的并发编程语言可以帮助程序员正确地表达他们的意图，从而避免某些类型的并发错误。**在这个方向上，事务内存（Transactional Memory，TM）[1,2,15,16,25,26,27,36]是一个流行的趋势之一。TM提供给程序员一种更简单的方式来指定哪些代码区域应该是原子的。此外，它通过底层硬件和软件支持自动保护指定区域的原子性，防止与其他指定区域的冲突。尽管TM显示出巨大的潜力，但仍存在许多未解决的问题，包括：（i）使用TM可以避免多少比例的错误？（ii）TM设计需要关注哪些现实世界的问题？（iii）除了TM之外，还有哪些编程语言支持对程序员编写正确并发程序是有帮助的？

解决上述所有方向中的未解决问题<u>**将从对现实世界并发错误特征的更好理解**</u>中获得显著好处 - 基本上，我们可以从程序员在编写并发程序时常见的错误中学习。例如，如果许多现实世界的并发错误涉及多个共享变量，我们需要扩展并发错误检测技术以解决多变量并发错误；如果大多数现实世界并发错误的表现通过两个线程之间的部分顺序保证，那么并发程序的测试只需要涵盖每对程序线程之间的两两交错。如果在避免现实世界并发错误时使用现有的同步原语存在一些问题，我们可以扩展事务内存模型或设计新的语言支持，以进一步简化编写并发程序的过程；如果某种类型的信息在修复现实世界并发错误时程序员经常使用，那么错误检测工具可以扩展以提供这种信息，并在实践中变得更加有用。

过去，许多<u>**关于一般程序错误特征的实证研究**</u>（不仅限于并发错误）已经进行过。它们的发现为错误检测、测试和编程语言设计提供了有用的指导和动力。例如，上世纪90年代对IBM软件系统中错误类型的研究[38]展示了内存错误的重要性，并激发了许多商业和开源的内存错误检测工具，如Purify[18]、Valgrind[30]、CCured[29]等。最近一项对操作系统错误的研究[8]揭示了复制粘贴是语义错误的重要原因，并启发了一个名为CP-Miner的工具，专注于检测复制粘贴的代码和与复制粘贴相关的语义错误[19]。

不幸的是，关于现实世界并发错误特征的研究很少。此前，意识到这种研究的重要性，研究人员进行了关于并发错误特征的初步工作[11]。然而，他们的观察是基于学生故意制造的有错误的程序进行特征研究的。

缺乏一份良好的现实世界并发错误特征研究主要有以下两个原因：（1）收集现实世界并发错误很困难，特别是因为它们通常被低估报告。正如以前的工作中观察到的[6]，非确定性使用户难以报告并发错误，并且使并发错误报告难以被程序员理解和解决。因此，收集一组良好的现实世界并发错误是耗时的。（2）并发错误并不容易理解。它们的模式和表现通常涉及多个程序组件之间复杂的相互作用，因此很难理解。

### 1.2 Contributions

根据我们目前的了解，本研究提供了**第一份全面的现实世界并发错误特征研究**。具体而言，我们<u>对现实世界并发错误的错误模式、表现、修复策略和其他特征进行了研究</u>。我们的研究基于随机选择的105个现实世界并发错误，其中包括74个非死锁错误和31个死锁错误，这些错误来自于4个成熟的开源应用程序：MySQL、Apache、Mozilla和OpenOffice，代表了服务器和客户端应用程序。对于每个错误，我们仔细研究了其错误报告、相应的源代码、相关的修补程序和程序员的讨论，所有这些都共同为我们提供了对错误模式、表现条件、修复策略和诊断过程相对深入的了解。

我们的研究揭示了许多有趣的发现，为并发错误检测、并发程序测试和并发编程语言设计提供了有用的指导。我们在表1中总结了我们的主要发现及其影响。

尽管我们认为我们研究的应用程序和错误很好地代表了大量的并发应用程序，但我们并不打算对所有并发应用程序得出一般性结论。特别要注意的是，我们在本研究中获得的所有特征和发现都与我们所研究的四个应用程序及其所使用的编程语言相关。因此，结果应当考虑到特定的应用程序和我们的评估方法（参见第2.3节关于有效性威胁的讨论）。

![image-20230716102350871](../../../Library/Application Support/typora-user-images/image-20230716102350871.png)

## 2. Methodology

### 2.1 Bug sources

**应用程序**：在我们的研究中，我们选择了四个代表性的开源应用程序：MySQL、Apache、Mozilla和OpenOffice。这些应用程序都是成熟的（拥有9至13年的开发历史）大型并发应用程序（代码行数为100万至400万行），并且有着良好维护的错误数据库。这四个应用程序代表了不同类型的服务器应用程序（数据库和Web服务器）和客户端应用程序（浏览器套件和办公套件）。这些应用程序中使用并发的目的各不相同。服务器应用程序主要使用并发处理并发客户端请求。它们可以同时运行数百或数千个线程。客户端和办公应用程序主要使用并发来同步多个图形用户界面（GUI）会话和后台工作线程。

**错误**：我们从这些应用程序的错误数据库中随机收集并发错误。由于这些数据库包含超过50万个错误报告，为了有效地从中收集并发错误，我们使用了与并发错误相关的大量关键词，例如“race(s)”，“deadlock(s)”，“synchronization(s)”，“concurrency”，“lock(s)”，“mutex(es)”，“atomic”，“compete(s)”以及它们的变体。从包含上述关键词集中至少一个关键词的数千个错误报告中，我们随机选择约500个具有清晰、详细的根本原因描述、源代码和错误修复信息的错误报告。然后，我们通过人工检查确保这些错误实际上是由程序员对并发执行的错误假设引起的，并最终得到了105个并发错误。

我们分别研究了**两种类型的并发错误：死锁错误和非死锁并发错误**。这两种类型的错误具有完全不同的特性，并且需要不同的检测和修复方法。因此，为了便于研究，我们对它们进行了分开处理。最终，我们收集了105个并发错误，其中包括74个非死锁并发错误和31个死锁错误。详细信息请参见表3

![image-20230716103151822](../../../Library/Application Support/typora-user-images/image-20230716103151822.png)

### 2.2 Characteristic categories

为了为未来关于并发程序可靠性的研究提供指导，在本研究中，我们重点关注并发错误特征的三个方面：**错误模式、表现和错误修复策略**。其他特征，如故障影响和错误诊断过程，将在最后简要讨论。

（1）在**错误模式**方面，我们根据并发错误的<u>根本原因将非死锁并发错误分为三类</u>（原子性违规错误、顺序违规错误和其他错误），即违反了什么类型的同步意图。详细定义请参见表2。在这里，我们不将数据竞争归类为错误模式。原因是数据竞争可能表示存在并发错误，但在许多情况下它也可能是一种良性竞争，例如标志位。此外，无数据竞争并不意味着没有并发错误。我们没有进一步将死锁分为子类，因为大多数死锁相对类似和简单。

（2）对于**表现特征**，我们研究了<u>每个并发错误展现所需的条件</u>（称为表现条件，在表2中定义），然后根据在其表现条件中涉及的<u>线程数量、变量（资源）数量和访问数量</u>来讨论并发错误。

（3）对于**错误修复策略**，我们研究了<u>最终修补程序的修复策略以及中间修补程序中的错误</u>。我们还评估了事务内存在<u>避免这些错误方面的作用</u>。所有相关分类信息均显示在表2中。

![image-20230716104456082](../../../Library/Application Support/typora-user-images/image-20230716104456082.png)

### 2.3 Threats to Validity

与先前的研究类似，现实世界特征研究都存在着有效性问题。我们的特征研究的有效性可能面临以下潜在威胁：<u>应用程序的代表性、我们研究中使用的并发错误，以及我们的检查方法</u>。

关于应用**程序的代表性**，我们的研究选择了四个基于C/C++编写的服务器和客户端并发应用程序，这是这些应用程序类型的流行编程语言。我们相信这四个应用程序很好地代表了基于服务器和客户端的并发应用程序，这是两个大类并发应用程序。然而，我们的研究可能无法反映其他类型的应用程序（例如科学应用程序、操作系统或使用其他编程语言编写的应用程序）的特征。

关于**错误的代表性**，我们研究的并发错误是<u>从上述应用程序的错误数据库中随机选择的</u>。它们为这些应用程序中的已修复错误提供了良好的样本。虽然未修复或未报告的并发错误的特征可能会有所不同，但这些错误不太可能像我们研究中所检查的已报告和已修复的错误那样重要。

就我们的**检查方法**而言，我们检查了与<u>每个研究的错误相关的所有信息，包括程序员的清晰解释、论坛讨论、源代码补丁、多个版本的源代码和触发错误的测试用例</u>。此外，我们对所研究的应用程序也非常熟悉，因为我们在我们之前发表的许多工作中对它们进行了修改和使用[22,23,35]。

总体而言，尽管我们的结论不能适用于所有并发程序，但我们相信我们的研究**捕捉到了两个重要的并发应用程序类别（基于服务器和基于客户端应用程序）中并发错误的特征**。此外，大部分这些特征在所有四个研究的应用程序中都是一致的，这表明我们的评估方法在一定程度上是有效的。此外，我们并不强调任何定量的特征结果。最后，我们还警告读者将我们的发现与上述方法和所选应用程序一起综合考虑。

## 3. Bug pattern study

不同的错误模式通常需要不同的检测和诊断方法。在表4中，我们将研究的非死锁并发错误的模式分为三类：原子性（Atomicity）、顺序（Order）和其他（Other），这些在表2中进行了描述。请注意，这些类别是根据错误的根本原因来区分的，而不考虑可能的错误修复策略。

``` 发现（1）：在所研究的非死锁并发错误中，大多数（72个中的74个）都可以归类为两种简单的模式：原子性违规和顺序违规。
发现（1）：在所研究的非死锁并发错误中，大多数（72个中的74个）都可以归类为两种简单的模式：原子性违规和顺序违规。
含义：并发程序的错误检测、测试和语言设计应首先集中在这两个主要的错误模式上。
```

这个发现（1）可以通过程序员通常将其意图放在原子区域和执行顺序上这一事实来解释，但在实现中正确且完全地强制执行所有这些意图并不容易。

由于程序员是**按顺序思考**的，他们往往会**假设小的代码区域将以原子方式执行**。例如，在图1中，程序员假设如果S1从thd->procinfo中读取一个非NULL值，S2也会读取相同的值。然而，在并发执行期间，这种原子性假设可能会被S3违反，从而导致程序崩溃。

![image-20230716160958190](../../../Library/Application Support/typora-user-images/image-20230716160958190.png)

程序员还经常**假设不同线程中的两个操作之间存在顺序，但程序员可能会忘记强制执行这样的顺序**。因此，这两个操作中的一个可能比程序员的假设更快（或更慢）执行，这就导致了顺序错误的出现。在图2中展示的Mozilla错误中，程序员很容易错误地假设在线程1初始化mThread之后，线程2会对mThread进行解引用，因为线程2是由线程1创建的。然而，在实际执行中，线程2可能非常快速，并在mThread初始化之前对mThread进行解引用。这种意外的顺序导致程序崩溃。请注意，即使可以使用锁来修复错误，但错误的根本原因并不是原子性违规，而是顺序违规。

![image-20230716161150673](../../../Library/Application Support/typora-user-images/image-20230716161150673.png)

违反程序员**其他意图的并发错误**也存在，但如表4所示，它们较为罕见。图3显示了一个示例。在MySQL的某个版本中，程序员使用<u>超时阈值（fatal timeout）来检测死锁</u>。如果任何一个线程等待一个锁的时间超过了致命超时时间，服务器将会崩溃。然而，当程序员设置这个阈值时，他们低估了工作负载。因此，用户发现在重负载下（使用2048个工作线程设置），MySQL服务器一直崩溃。这种与性能相关的假设既不是原子性意图也不是顺序意图。通过限制工作线程的数量来修复了这个错误。

![image-20230716162302756](../../../Library/Application Support/typora-user-images/image-20230716162302756.png)

```
发现（2）：在所研究的非死锁并发错误中，有相当数量（24个中的74个）是顺序错误，这些错误在先前的错误检测工作中没有得到解决。
含义：需要新的错误检测技术来解决顺序错误。
```

正如我们之前讨论的，程序员通常会假设两个线程之间存在某种操作的特定顺序。具体而言，程序员可以有以下顺序意图：

i) 在一个变量的写操作和读操作之间（图2）；

ii) 在一个变量的两个写操作之间（图4）；

iii) 在一组变量的一组访问操作之间（图5）。

在图4中，程序员期望S2在分配一个新值FALSE给iopending之前初始化。然而，异步读操作的执行可能非常快，导致S4在S2之前执行，与程序员的期望相反。这导致线程1挂起。在图5中的另一个示例中，jsUnpinPinnedAtom会释放atoms数组中的所有元素。这组对整个数组的内存访问预计会在jsMarkAtom之后发生，而jsMarkAtom可能会访问一些atoms数组中的元素。

请注意，上述的顺序错误与数据竞争错误和原子性违规错误是不同的。即使对同一个变量的两次内存访问都由相同的锁保护，或者两个相冲突的代码区域对彼此是原子的，它们之间的执行顺序仍然无法保证。我们还应该注意到，一些顺序违规错误可以通过使用更粗粒度的锁来修复，例如图2和图4中的示例；而其他一些错误则无法通过锁来修复，例如图5和图7中的示例（稍后将进行讨论）。这与错误的根本原因无关，并且不会影响我们的错误模式分类。

尽管顺序违规错误很重要且常见，但它们在先前的研究中没有得到很好的研究。许多顺序错误将<u>**被现有的并发错误检测器所忽略**</u>，这些检测器主要关注竞争错误或原子性错误。因此，需要新的技术来解决顺序问题。

![image-20230717104027756](../../../Library/Application Support/typora-user-images/image-20230717104027756.png)

## 4. Bug manifestation study

并发错误的表现条件通常是一组内存访问或系统事件之间的特定顺序。在本节中，我们根据表2中定义的方法论研究了真实世界**并发错误的表现特征**。我们将根据观察结果讨论**并发程序测试和并发错误检测**的指导方针。

### 4.1 How many threads are involved？线程：成对

```
发现(3)：大多数（101个中的105个）所研究的并发错误的表现涉及不超过两个线程
含义：并发程序测试可以对程序线程进行成对测试，从而减少测试复杂性，同时不会丧失暴露错误的能力。
```

发现(3)告诉我们，尽管所研究的服务器程序使用了数百个线程，在大多数情况下，只有很少数量的线程（主要只有两个）参与了并发错误的表现。

这背后的原因是大多数线程与其他线程之间的交互并不密切，大部分的通信和协作都是在两个或小组线程之间进行的。因此，大多数并发错误的表现条件并不涉及多个线程。例如，在第3节中介绍的所有错误中，除了图3中的错误，如果它们的执行遵循两个线程之间的特定部分顺序（在图中用虚线表示），它们都会被保证发生。

我们应该注意到，这一发现并不与常见观察相矛盾，即并发错误有时在高负载（许多线程的并发执行）下更容易显现出来。在许多情况下，错误的表现条件仅涉及两个线程。高负载增加了资源竞争和上下文切换的强度。因此，它增加了触发错误的两个线程之间特定顺序的可能性。然而，错误的表现条件仍然只涉及两个线程。

我们的发现意味着测试可以**将重点放在每对线程之间的访问执行顺序上**。这种逐对测试技术可以防止测试复杂度随线程数量呈指数增长。同时，很少会错过并发错误。

```
发现（4）：31个死锁并发错误中有7个错误的显现只涉及一个线程。
含义：这种类型的错误相对容易检测和避免。错误检测和编程语言技术应该首先尝试消除这些简单的错误。
```

通常发生在一个线程试图获取自身持有的资源时。检测和分析这种类型的错误相对容易，因为我们不需要考虑其他并发执行组件的竞争。

### 4.2 How many variables are involved?变量：大部分是单个（简化），也要关注多变量

并发错误的同步问题是针对一个变量还是多个变量之间的问题？为了回答这个问题，我们检查了每个并发错误在表现过程中涉及的变量（或资源）数量。检查结果如表6所示。

```
发现（5）：经过检查，被研究的非死锁并发错误中有66％（49个中的74个）仅涉及一个变量。
含义：专注于对单个变量的并发访问是并发错误检测的一个很好的简化方法。
```

![image-20230717154628918](../../../Library/Application Support/typora-user-images/image-20230717154628918.png)

结果（5）证实了我们的直觉。改变对不同内存位置的两次访问的顺序不会直接改变程序状态，因此不太可能引发问题。图1、2和4都是单变量并发错误的例子：它们的表现可以**通过对一个变量的访问顺序的特定要求**来保证。

这一发现支持了许多现有错误检测工具所采用的单变量假设。例如，数据竞争错误检测[37,42]会检查对一个变量的访问之间的同步情况；一些原子性违规错误检测工具也专注于与一个变量相关的原子性区域[23,41]。

```
发现（6）：非常多（34%）的非死锁并发错误涉及多个变量
含义：我们需要新的并发错误检测工具来处理涉及多个变量的并发错误。
```

多个变量的并发错误通常发生在未同步访问相关变量导致程序状态不一致的情况下。**变量之间的语义连接**很常见，因此**多个变量的并发错误**也很常见。

图6展示了Mozilla中的多变量并发错误的例子。在这个例子中，mOffset和mLength一起标记了存储在dynamicstringmContent中的有效字符的区域。线程1和线程2对这三个变量的并发访问应该进行同步，否则线程1可能读取不一致的值并访问无效的内存地址。在这里，控制对任何单个变量的内存访问顺序不能保证错误的发生。例如，线程1在线程2对这三个变量进行修改之前或之后读取mContent都是没有问题的。错误发生的条件是线程1在线程2对这三个变量进行修改的过程中使用了这三个相关的变量。

![image-20230717154649161](../../../Library/Application Support/typora-user-images/image-20230717154649161.png)

正如上面所讨论的，**大多数现有的错误检测工具仅关注单变量并发错误**。尽管这种**简化**为并发错误检测提供了一个良好的起点，但未来的研究**不应忽视多变量并发错误的问题**。

**检测多变量并发错误的困难**在于<u>针对不同的变量，很难推断哪些访问操作，需要进行良好的同步</u>。解决这个问题不仅有助于自动并发错误检测，还能为程序员提供有用的提示，以便为事务内存或原子性错误检测工具指定正确的事务或原子区域[12]。

```
结果(7)：我们检查的31个死锁并发错误中，有97%（30个）涉及最多两个资源。
含义：面向死锁的并发程序测试可以对两个资源的获取和释放顺序进行成对测试。
```

在经过检查的死锁错误中，只有一个错误是由三个线程循环等待三个资源触发的。利用这一发现，通过对资源进行成对测试，可以防止测试复杂度随资源总数的指数增长。

### 4.3 How many accesses are involved?访问次数：

我们发现大多数并发错误的表现只涉及两个线程和少量变量。然而，一个线程对每个变量的访问次数仍然可能非常多。因此，我们需要研究在错误的表现中涉及了多少次访问。

```
发现（8.1）：在我们研究的大多数（67个中的90%）非死锁并发错误中，只要强制执行最多四个内存访问之间的特定顺序，就可以确定地显示出这些错误。
发现（8.2）：在我们研究的大多数（30个中的97%）死锁并发错误中，只要强制执行最多四个资源获取/释放操作之间的特定顺序，就可以确定地显示出这些错误。
含义：并发程序测试可以将重点放在每个小组访问之间的部分顺序上。这将使交织测试空间从指数级降低到多项式级别，减少了暴露错误的能力，同时也减少了测试复杂度。
```

发现（8.1）可以很容易地理解，考虑到大多数被检测的并发错误具有简单的模式并涉及少量的变量。大部分异常情况来自于涉及两个以上线程和/或两个以上变量的错误。

发现（8.2）也是自然的，考虑到我们检测的大部分死锁错误只涉及两个资源。

上述发现对**并发程序测试**具有重要意义。**并发程序测试的挑战**在于所有可能的**交错数量**与**动态内存访问数量**呈指数关系，这使得全面探索变得非常困难。**我们的研究结果支持一种更有效的交错测试设计[21]：在每个小组的内存访问中探索所有可能的顺序，例如4个内存访问的小组。**这种设计的复杂度与动态内存访问数量呈多项式关系，相对于指数级的全交错测试方案来说，大大降低了复杂度。此外，这种设计的错误暴露能力几乎与全交错测试相当。它只会错过我们研究中的少数错误。

最近的一个模型检查工作[28]**使用启发式方法从具有少量上下文切换的交错开始检查**。我们的研究结果为这种启发式方法提供了支持。

当然，强制执行一组访问之间的特定部分顺序并不容易。需要控制程序输入和许多访问来实现这一点。如何利用我们的发现来实现实际而强大的并发程序测试和模型检查仍然是未来的工作。

![image-20230717173046591](../../../Library/Application Support/typora-user-images/image-20230717173046591.png)

## 5. Bug fix study

### 5.1 Fix strategies

在我们检查真实世界的错误被修复之前，我们猜测最常见的修复并发错误的方法是添加或更改锁。然而，根据我们的特征结果（如表8所示），与我们的猜测相反。

![image-20230717230849979](../../../Library/Application%20Support/typora-user-images/image-20230717230849979.png)

```
发现（9）：添加或更改锁并不是主要的修复策略。在我们检查的74个非死锁并发错误中，只有20个错误使用了这种策略。
含义：没有一种万能的方法来修复并发错误。仅仅告诉程序员某些冲突的访问没有受到相同锁的保护是不足以修复并发错误的。
```

**原因**有两个。首先，锁无法保证实现某些同步意图，比如A应该在B之前发生。因此，添加/更改锁不能修复某些类型的错误。图5展示了这样一个例子。在图7中，我们展示了另一个简单的例子。其次，即使添加/更改锁可以修复一个bug，在许多情况下，这不是最佳策略，因为它可能会影响性能或引入新的错误，比如死锁错误。

在接下来的内容中，我们将描述程序员使用的除添加/更改锁之外的**不同策略**。我们会发现<u>这些策略通常需要对程序语义有深入的理解</u>。与此同时，它们通常比相应的基于锁的修复方法（如果存在）<u>具有更好的性能</u>。

(1) 条件检查（COND）：条件检查可以以不同的方式用于帮助修复并发错误。一种方式是使用 while-flag 来修复与顺序相关的错误，例如图5中所示的错误。另一种方式是添加一致性检查来监视与错误相关的程序状态。这使得程序能够检测到错误的交错执行并恢复程序状态。例如，为了修复图6中的错误，程序在执行 putc 函数之前会进行一致性检查 if(strlen(mContent)>=mOffset+mLength)。如果一致性检查失败，则会跳过 putc 操作。在图8中的另一个示例中，会检查条件 (n!=block->n) 来判断自上次读取以来，共享变量 block->n 是否已被修改。如果 n 与 block->n 不一致，则程序会回滚并重新读取 block->n。需要注意的是，上述修复策略并未消除错误的交错执行，这通常是基于锁的修复方法的目的。相反，它侧重于检测错误的交错执行并确保由错误交错执行破坏的程序状态能够及时恢复。与相应的基于锁的修复方法相比，它具有更好的性能。

![image-20230717232310733](../../../Library/Application Support/typora-user-images/image-20230717232310733.png)

（2） 代码交换（Switch）：交换特定代码语句的顺序可以修复某些与顺序相关的错误。例如，图4中的顺序错误可以通过交换语句S1和S2的顺序来修复，使得S2始终在S4之前执行。

（3）算法/数据结构设计更改（Design）：这包括不同类型的算法更改和数据结构更改，有助于实现正确的同步。一些设计更改是简单的，只需修改一些数据结构。例如，在MySQL的Bug #7209中，该bug是由于对共享变量HASH::currentrecord的未保护冲突访问引起的。程序员意识到这个变量不需要共享，他们简单地将字段currentrecord从类HASH中移出，使其成为每个线程的局部变量，并修复了该bug。另一个例子是在Mozilla的Bug #201134中，一个线程需要对共享变量nsCertType进行一系列操作。为了确保这一系列操作的原子性，程序员只需将nsCertType读入一个局部变量中，对局部变量进行操作，并在最后将值存回nsCertType。一些设计更改则更为复杂，涉及算法的重新设计。例如，在Mozilla的Bug #131447中，程序员更改了消息处理和排队算法，以容忍在相应的回调函数准备好之前回复消息到达的特殊时机。

正如我们所看到的，修复并发错误要比仅仅添加或更改锁操作复杂得多。竞争检测工具可以帮助程序员进行与锁相关的修复，但这还不够。我们希望有更多的工具来帮助程序员确定错误模式、与每个错误相关的一致性条件等。例如，如果程序员知道该错误是一个顺序违规错误，并且他们也知道一致性条件是什么，那么很容易想出一个条件检查的修复方法。这是未来关于并发错误检测和诊断的研究所面临的挑战。

```
发现(10)：对于所检测的31个死锁并发错误中，最常见的修复策略（在19个案例中使用）是让一个线程放弃获取一个资源，比如一个锁。这种策略简单易行，但可能会引入其他非死锁错误。
含义：我们需要关注一些已修复的死锁并发错误的正确性。
```

在许多情况下，程序员发现在某些程序上下文中获取锁是不必要的或不值得的。因此，他们只是放弃了资源的获取以避免死锁。

然而，这种策略可能会引入非死锁的并发错误。在我们研究的一些错误报告中，程序员明确表示他们知道修复操作会引入一个新的非死锁的并发错误。然而，他们仍然采用修复策略，因为他们认为新的非死锁并发错误发生的概率很小。在未来，结合乐观并发和回滚-重执行等技术，如事务内存（TM），可以帮助修复一些死锁错误。当然，使用这些技术也需要谨慎，因为它们可能引入活锁问题。

### 5.2 Mistakes during bug Fixing

修复错误是困难的。程序员发布的一些补丁仍然存在错误。为了调查错误补丁的本质，我们收集了57个Mozilla并发错误的所有不同错误补丁。具体而言，我们首先收集了Mozilla程序员提交的这57个错误的所有中间（非最终）补丁。然后，我们手动检查每个补丁并过滤掉非修复错误的补丁，这些补丁只更改注释或代码结构用于维护目的。

我们的研究发现，57个Mozilla错误中有17个至少有一个错误补丁。平均而言，每个最终正确的补丁之前发布了0.4个错误补丁。在这23个不同的错误补丁中，有6个只减少了原始并发错误的发生概率，但未能完全修复原始错误（如图9所示）。其中5个引入了新的并发错误，另外12个引入了新的非并发错误。程序员需要帮助来提高他们补丁的质量。

### 5.3 Discussion: bug avoidance

良好的编程语言应该在实现过程中有助于避免一些错误。事务内存（TM）是简化并发编程的流行趋势的编程语言特性。为了评估其优势以及在这个方向上还需要做什么，我们研究了105个并发错误，以查看其中有多少可以通过TM支持潜在地避免。此外，我们还研究了未来并发编程语言设计需要解决的问题。

再次强调，我们的分析应该考虑到我们<u>研究的应用程序和评估方法</u>，如第2.3节所讨论的。

研究重点：TM的基本原子性和隔离性属性

研究目的：提供更多实际的信息，帮助改进TM的设计。

```
发现(11): TM可以帮助避免许多并发错误(我们检查的105个并发错误中的41个)。
含义：尽管TM并非万能解药，但它在许多情况下可以帮助程序员正确表达他们的同步意图，并帮助避免大部分并发错误。
```

原子性违规错误和具有相对较小且简单的关键代码区域的死锁错误可以从TM中获益最多，TM可以帮助程序员明确指定这种类型的原子性意图。图8展示了一个示例，在这里，程序员使用一致性检查和重新执行来修复该错误。在这种情况下，事务（带有中止、回滚和重放）正是程序员所期望的解决方案。

```
发现（12）：如果能够解决一些问题，TM有可能帮助避免许多并发错误（在我们研究的105个并发错误中有44个），如表10所示。
含义：TM设计可以结合系统支持和其他技术来解决一些问题，并进一步简化并发编程。
```

一个关注点是I/O操作，这并不令人惊讶。由于像I/O这样的操作很难回滚，使用TM来保护包含此类操作的代码区域的原子性是困难的。以图1中的并发bug为例。由于S2涉及文件操作，TM可能需要使用非平凡的撤销技术来保护S1至S2的原子区域。

还有其他一些问题，比如原子区域的大小和特殊代码性质。例如，几个 Mozilla Bug 中的原子代码区域包括整个垃圾回收过程。这些区域可能具有过大的内存占用，导致硬件事务内存难以有效处理。

上述的许多问题在事务内存中是可以解决的，但会带来更高的开销和复杂性。例如，一些回滚相关的问题可以通过系统支持来解决。非常长的事务可以通过结合软件和硬件事务内存来解决。

```
发现(13)：我们研究的105个并发错误中，有20个无法从基本的TM设计中受益，因为基本的TM无法保证程序员的意图，如顺序意图。
含义：除了原子性意图之外，还存在着明显的需求，即并发编程语言需要提供功能来帮助程序员轻松地表达顺序意图。
```

程序员的顺序意图是无法通过基本的TM设计或锁定轻松实施的主要类型意图。一般来说，基本的TM设计无法帮助实施"A必须在B之前执行"的意图。因此，它们无法避免许多相关的顺序违反错误。在所有的顺序违反错误中，我们发现了一种特殊类型的顺序意图，即A必须要么在B之前执行，要么根本不执行。换句话说，程序员不希望B等待A的执行。如果B已经执行，程序会简单地跳过任何在缓存被销毁后的插入尝试。这在7个错误中发生。

为了帮助避免以上20个错误，**基本TM的语义设计需要增强，而不仅仅是实现方案**。最近的一些TM设计[5,17]**配备了丰富的语义（如观察/重试、重试/或其他）**，可以帮助实施上述一些同步意图。我们希望我们的错误特征研究能够帮助未来的研究确定最佳的TM设计。

## 6. Other characteristics

错误的影响：在我们研究的并发错误中，有34个可能导致程序崩溃，而37个可能导致程序停滞。这证实了并发错误是一个更严重的可靠性问题。

有些并发错误非常难以重现。在一份错误报告中（Mozilla #52111），报告者抱怨说“我整天都在开发Mozilla，每天只能遇到这个错误一次”。在另一个错误报告中（Mozilla #72599），报告者表示“我只在一台机器上看到过一次，其他机器上从未出现过。也许是由于gm的双处理器才导致的”。

测试用例对于错误诊断非常关键。程序员的讨论显示，一个能够重现并发错误的良好测试用例对于诊断非常重要。在Mozillabug报告#73291中，程序员曾放弃该错误并关闭了错误报告，因为他们无法重现该错误。幸运的是，有人找到了一种可靠地重现该错误的方法，随后该错误被修复。在另一个Mozillabug报告中（Mozilla #72599），程序员最终放弃了重现该错误的尝试，并仅仅根据他们的“猜测”提交了一个补丁，结果导致了错误的修复。程序员缺乏诊断工具。从错误报告中，我们注意到许多并发错误仅仅通过程序员阅读源代码进行诊断。例如，在57个Mozillabug中，有29个错误报告没有提到程序员利用任何工具、核心转储或堆栈跟踪等信息。有时程序员会尝试使用gdb，但无法获取有用的信息。我们从未见过程序员提到他们使用过任何自动诊断工具。相比之下，在许多关于内存错误的错误报告中，程序员提到他们从Valgrind、Purify等工具中得到了帮助。

## 7. Related work

**漏洞特征研究**
在大型软件系统中，已经进行了大量的工作来研究漏洞的特征。其中许多研究从不同方面提供了宝贵的信息，以帮助提高软件的可靠性，包括漏洞检测[8,38]、容错性[14]、故障恢复[6]、故障预测和测试[32]等。在最近的一项研究中[43]，人们还研究了最近的趋势（商业工具的可用性、开源等）对所有漏洞的一般特征（漏洞分布、修复时间）的影响。不幸的是，以前很少有研究关注并发漏洞，可能是因为现实世界中的并发漏洞很难收集和分析。例如，在以前的一项研究中[6]，只收集了来自三个应用程序（MySQL、GNOME和Apache）的12个并发漏洞。在这种情况下，以前的并发漏洞模式研究[11]不得不要求学生有意地编写包含漏洞的并发程序，这不能很好地代表真实世界的漏洞特征。与以前的工作不同，我们研究了来自4个大型开源应用程序的105个真实世界并发漏洞的模式、表现和修复。我们的研究为解决并发编程中的正确性问题提供了许多发现和启示。

**提高并发程序的可靠性**
改进并发程序质量的技术与我们的工作相关。由于篇幅限制，这里我们简要讨论了在前面章节中未涉及的工作。在软件测试方面，人们提出了不同的覆盖准则，以有选择地测试并发程序的交错执行。不幸的是，这些提议要么过于复杂[39]，要么基于启发式算法[4,9]。我们对并发漏洞表现的研究可以帮助理解测试复杂性和漏洞暴露能力之间的权衡，并有助于设计更好的覆盖准则。在编程语言领域，除了事务内存之外，还研究了其他设计。AtomicSet[40]将同步约束与数据相关联，而不是与代码区域相关联。这种设计可以帮助避免一些与多个变量相关的并发漏洞。AutoLocker[24]通过自动分配锁来简化程序员指定的原子区域。我们的特征研究为这些新的语言特性提供了更多的动力。

## 8. Conclusions and future work

本文对现实世界中的并发漏洞进行了全面的研究，考察了它们的**模式、表现、修复策略和其他特征**。我们的研究基于从四个代表性的开源程序（MySQL、Apache、Mozilla和OpenOffice）中**随机收集的105个现实世界的并发漏洞**。我们的研究结果<u>包含了许多有趣的发现和对并发漏洞检测、测试和并发编程语言设计的启示</u>。未来的研究可以从我们的研究中受益，例如<u>设计新的漏洞检测工具来解决多变量漏洞和顺序违规漏洞</u>；可以<u>对并发程序线程进行配对测试，并集中于对小组内存访问的部分顺序，以充分利用测试工作</u>；<u>可以拥有更好的语言特性来支持进一步简化并发编程中的"顺序"语义</u>。在未来，我们将扩展我们的研究以涵盖其他类型的现实世界应用程序。