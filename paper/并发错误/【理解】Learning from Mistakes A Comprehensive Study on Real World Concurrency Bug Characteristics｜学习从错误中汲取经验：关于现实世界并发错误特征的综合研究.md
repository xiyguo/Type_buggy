## 3. Bug pattern study



```发现（1）：在所研究的非死锁并发错误中，大多数（72个中的74个）都可以归类为两种简单的模式：原子性违规和顺序违规。
发现（1）：在所研究的非死锁并发错误中，大多数（72个中的74个）都可以归类为两种简单的模式：原子性违规和顺序违规。
影响：并发程序的错误检测、测试和语言设计应首先集中在这两个主要的错误模式上。
```

发现一的产生原因：

1. 假设小的代码区域以原子方式执行。但实际并非原子。
2. 假设不同线程的两个操作存在顺序，但是没有强制执行这个顺序。即原预设顺序被打乱。
3. 程序员的其他意图导致的并发错误。（如：设置阈值导致并发被限制）



```
发现（2）：在所研究的非死锁并发错误中，有相当数量（24个中的74个）是顺序错误，这些错误在先前的错误检测工作中没有得到解决。
影响：需要新的错误检测技术来解决顺序错误。
```

发现二的产生原因：

1. 在一个变量的写操作和读操作之间（图2）；
2. 在一个变量的两个写操作之间（图4）；
3. 在一组变量的一组访问操作之间（图5）。



## 4. Bug manifestation study

### 4.1 How many threads are involved？线程：成对

```
发现(3)：大多数（101个中的105个）所研究的并发错误的表现涉及不超过两个线程
含义：并发程序测试可以对程序线程进行成对测试，从而减少测试复杂性，同时不会丧失暴露错误的能力。
```

将重点放在每对线程之间的访问执行顺序上。

```
发现（4）：31个死锁并发错误中有7个错误的显现只涉及一个线程。
含义：这种类型的错误相对容易检测和避免。错误检测和编程语言技术应该首先尝试消除这些简单的错误。
```

检测和分析单线程任务很容易，因为不涉及资源竞争。

### 4.2 How many variables are involved?变量：大部分是单个（简化），也要关注多变量

```
发现（5）：经过检查，被研究的非死锁并发错误中有66％（49个中的74个）仅涉及一个变量。
含义：专注于对单个变量的并发访问是并发错误检测的一个很好的简化方法。
```

可以**通过对一个变量的访问顺序的特定要求**来保证。支持了许多现有错误检测工具所采用的单变量假设。

```
发现（6）：非常多（34%）的非死锁并发错误涉及多个变量
含义：我们需要新的并发错误检测工具来处理涉及多个变量的并发错误。
```

变量之间的语义链接导致了多个变量的并发错误。



“大多数现有的错误检测工具仅关注单变量并发错误，有简化功能，但是也应该关注多变量。”

**检测多变量并发错误的困难**在于<u>针对不同的变量，很难推断哪些访问操作，需要进行良好的同步</u>。



```
结果(7)：我们检查的31个死锁并发错误中，有97%（30个）涉及最多两个资源。
含义：面向死锁的并发程序测试可以对两个资源的获取和释放顺序进行成对测试。
```

通过对资源进行成对测试，可以防止测试复杂度随资源总数的指数增长。

### 4.3 How many accesses are involved?访问次数：四组组内

```
发现（8.1）：在我们研究的大多数（67个中的90%）非死锁并发错误中，只要强制执行最多四个内存访问之间的特定顺序，就可以确定地显示出这些错误。
发现（8.2）：在我们研究的大多数（30个中的97%）死锁并发错误中，只要强制执行最多四个资源获取/释放操作之间的特定顺序，就可以确定地显示出这些错误。
含义：并发程序测试可以将重点放在每个小组访问之间的部分顺序上。这将使交织测试空间从指数级降低到多项式级别，减少了暴露错误的能力，同时也减少了测试复杂度。
```

**我们的研究结果支持一种更有效的交错测试设计[21]：在每个小组的内存访问中探索所有可能的顺序，例如4个内存访问的小组。**

## 5. Bug fix study

### 5.1 Fix strategies

【除了添加或更改锁之外的策略】

猜测最常见的修复并发错误的方法是<u>添加或更改锁</u>。然而，特征结果与猜测相反。

```
发现（9）：添加或更改锁并不是主要的修复策略。在我们检查的74个非死锁并发错误中，只有20个错误使用了这种策略。
含义：没有一种万能的方法来修复并发错误。仅仅告诉程序员某些冲突的访问没有受到相同锁的保护是不足以修复并发错误的。
```

原因：

* <u>锁无法保证实现某些同步意图</u>，比如A应该在B之前发生。因此，添加/更改锁不能修复某些类型的错误。图5展示了这样一个例子。在图7中，我们展示了另一个简单的例子。
* 其次，即使添加/更改锁可以修复一个bug，在许多情况下，这<u>不是最佳策略</u>，因为它可能会影响性能或引入新的错误，比如死锁错误。

策略：

我们会发现<u>这些策略通常需要对程序语义有深入的理解</u>。与此同时，它们通常比相应的基于锁的修复方法（如果存在）<u>具有更好的性能</u>。

* 条件检查（COND）：条件检查可以以不同的方式用于帮助修复并发错误。
  * 一种方式是使用 <u>while-flag</u> 来修复与顺序相关的错误，例如图5中所示的错误。
  * 另一种方式是<u>添加一致性检查</u>来监视与错误相关的程序状态。<u>这使得程序能够检测到错误的交错执行并恢复程序状态</u>。
* 代码交换（Switch）：交换特定代码语句的顺序可以修复某些与顺序相关的错误。
* 算法/数据结构设计更改（Design）：这包括不同类型的算法更改和数据结构更改，有助于实现正确的同步。一些设计更改是简单的，只需修改一些数据结构。

未来关于并发错误检测和诊断的研究所面临的挑战：

竞争检测工具可以帮助程序员进行与锁相关的修复，但我们希望有更多的工具来帮助程序员**确定错误模式、与每个错误相关的一致性条件等**。

【删除无用锁】

```
发现(10)：对于所检测的31个死锁并发错误中，最常见的修复策略（在19个案例中使用）是让一个线程放弃获取一个资源，比如一个锁。这种策略简单易行，但可能会引入其他非死锁错误。
含义：我们需要关注一些已修复的死锁并发错误的正确性。
```

在某些程序上下文中获取锁是不必要的或不值得的。

然而，修复操作会引入一个新的非死锁的并发错误。但是，新的非死锁并发错误发生的概率很小。在未来，结合乐观并发和回滚-重执行等技术，如事务内存（TM），可以帮助修复一些死锁错误。当然，需要谨慎，可能引入活锁问题。

### 5.2 Mistakes during bug Fixing

修复错误是困难的。程序员发布的一些补丁仍然存在错误。平均而言，每个最终正确的补丁之前发布了0.4个错误补丁。程序员需要帮助来提高他们补丁的质量。

### 5.3 Discussion: bug avoidance

良好的编程语言应该在实现过程中有助于避免一些错误。**事务内存（TM）**是简化并发编程的流行趋势的编程语言特性。接下来，我们研究，<u>评估其优势以及在这个方向上还需要做什么</u>。

再次强调，我们的分析应该考虑到我们<u>研究的应用程序和评估方法</u>，如第2.3节所讨论的。

研究重点：TM的基本原子性和隔离性属性

研究目的：提供更多实际的信息，帮助改进TM的设计。



