# Learning from Mistakes — A Comprehensive Study on Real World Concurrency Bug Characteristic｜了解和检测真实世界的性能错误

## Abstract

开发人员经常使用低效的代码序列，可以通过简单的补丁来修复。这些低效的代码序列会导致严重的性能下降和资源浪费，称为性能错误。在多核时代，单线程性能的微小增长以及对能源效率的不断强调需要更多的努力来解决性能错误。

本文对从五个代表性的软件套件（Apache、Chrome、GCC、Mozilla和MySQL）中随机抽取的109个真实世界性能错误进行了全面的研究。本研究的发现为未来避免、暴露、检测和修复性能错误的工作提供了指导。

在我们的特征研究的指导下，从25个补丁中提取了效率规则，并用于检测性能错误。在MySQL、Apache和Mozilla应用程序的最新版本中发现了332个以前未知的性能问题，其中包括应用规则发现的219个跨应用程序的性能问题。

**类别和主题描述**：D.2.5 [软件工程]：测试和调试；D.4.8 [操作系统]：性能

**常见术语**：语言、测量、性能、可靠性

**关键词**：性能错误、特征研究、基于规则的错误检测

## 1.  Introduction

###  1.1 Motivation

缓慢和低效的软件很容易让用户感到沮丧，并导致经济损失。尽管研究人员已经花费数十年的时间来透明地提升软件性能，但性能错误仍然普遍地降低性能并浪费计算资源[40]。与此同时，由于对真实世界性能错误的认识不足，目前对于解决性能错误的支持还处于初步阶段。

按照开发人员和研究人员在这个领域的惯例[5, 26, 40, 50]，我们将**性能错误**称为**软件缺陷**，指的是<u>相对简单的源代码更改可以显著加快软件速度，同时保留功能</u>。这些缺陷无法通过现有的编译器进行优化，因此会影响最终用户。图1展示了一个真实世界的性能错误示例。Apache HTTPD开发人员在API升级后忘记更改aprstata的参数。这个错误导致Apache服务器的速度下降了十倍以上。

![image-20230718105544230](../../../../Library/Application Support/typora-user-images/image-20230718105544230.png)

**发布的软件中普遍存在性能错误。**例如，Mozilla开发人员在过去10年中每个月都会修复用户报告的5到60个性能错误。<u>性能错误的普遍存在是不可避免的，因为很少有工作帮助开发人员避免与性能相关的错误</u>。此外，性能测试主要依赖于<u>无效的黑盒随机测试</u>和<u>手动输入设计</u>，这导致大多数性能错误被忽略[40]。

性能错误会导致**现场的吞吐量降低、延迟增加和资源浪费**。在过去，它们曾导致多个备受关注的失败案例，使得价值数亿美元的软件项目被放弃[41, 45]。

更糟糕的是，由于性能问题的非停止式症状，**诊断这些问题是非常耗时的**。软件公司可能需要几个月的专家工作来找出导致其服务在99分位数延迟增加几百毫秒的少数性能错误[49]。

未来以下趋势将使性能错误问题变得更加紧迫：

**硬件**：多年来，摩尔定律确保了硬件的提升会随着时间推移而使软件变得更快，而无需进行软件开发的努力。在多核时代，当每个核心不太可能变得更快时，性能错误尤为有害。

**软件**：软件系统的复杂性不断增加，工作负载的快速变化为性能浪费提供了新的机会，也给诊断带来了新的挑战。

**能源效率**：不断上涨的能源成本为避免性能错误提供了有力的经济理由。当一个人愿意牺牲服务质量来降低能源消耗时，忽视性能错误是不可原谅的。

由于性能错误不会导致故障停止，因此它们可能没有像功能错误那样经常被报告。然而，考虑到对于解决性能错误的初步支持，当我们进入一个资源受限的计算世界时，是时候更加关注它们了。

### 1.2 Contribution 1: Characteristics Study

许多经验研究[7, 34, 43, 46, 53]已经针对导致软件功能不正确的传统错误（称为功能错误）进行了研究。这些研究成功地指导了功能软件测试、功能错误检测和故障诊断的设计。

**对性能错误的理解不足和错误的观念**，比如“性能由编译器和硬件负责”，部分原因是当今**性能错误问题的原因**[12]。对于诸如“性能错误是如何引入的”、“哪些输入条件会暴露性能错误”、“真实世界性能错误的常见根本原因是什么”以及“开发人员如何修复性能错误”等主题缺乏经验研究，严重限制了性能错误避免、测试、检测和修复工具的设计。

**避免错误的指导。**在研究的错误中，三分之二是由于开发人员对工作负载或API性能特性的错误理解引起的。超过四分之一的错误是由于工作负载或API的变化导致先前正确的代码出现问题。为了避免性能错误，开发人员需要面向性能的注释系统和变更影响分析。（第4.2节）

**性能测试的指导。**研究发现，近一半的错误需要具有特殊特性和大规模的输入才能显现出来。结合功能测试中使用的输入生成技术，并考虑大规模的性能测试方案，将显著改进现有技术水平。（第4.3节）

**对于错误检测的指导**。最近的研究工作[5, 11, 26, 47, 57, 58]已经展示了性能错误检测的潜力。我们的研究发现了真实世界性能错误的常见根本原因和结构模式，可以帮助提高性能错误检测的覆盖率和准确性（第4.1节和第4.5节）。

**对于错误修复和检测的指导。**近一半的检查过的错误补丁包括可重复使用的效率规则，可以帮助检测和修复性能错误（第4.4节）。

**与功能性错误的比较。**性能错误在软件中往往隐藏了更长的时间（第4.5节）。与功能性错误不同，性能错误不能都被建模为罕见事件，因为其中相当一部分可以被几乎所有输入触发（第4.3节）。

**总体动机**：
1）许多性能错误的<u>补丁都很小</u>。通过改变几行代码就能实现显著的性能改进的事实，激发了研究人员对性能错误的更多关注（第4.4节）。
2）多线程软件中相当一部分的<u>性能错误与同步相关</u>。开发人员需要工具支持来避免过度同步的陷阱（第4.3节）。

### 1.3  Contribution 2: Bug Detection

**基于规则的错误检测**对于**检测功能错误**是有效的[6, 21, 30, 42]。根据我们的特征研究，我们假设：**(1) 存在与效率相关的规则；(2) 我们可以从性能错误的补丁中提取规则；(3) 我们可以使用提取的规则来发现以前未知的性能错误。**

为了测试这些假设，我们从<u>25个Apache、Mozilla和MySQL的错误补丁</u>中收集了规则，并构建了<u>静态检查器</u>来查找违反这些规则的情况。

我们的检查器在Apache、Mozilla和MySQL的原始有错误版本中自动发现了<u>125个潜在的性能问题</u>（PPPs）。程序员未能与规则来自的原始25个错误一起修复它们。

我们的检查器还在<u>最新版本的</u>Apache、Mozilla和MySQL中<u>发现了332个以前未知的潜在性能问题</u>（PPPs）。其中包括通过使用从另一个应用程序中提取的规则来检查一个应用程序发现的219个PPPs。

我们进行了<u>彻底的代码审查和单元测试</u>，确认每个PPP的运行速度比检查器建议的保留功能的替代方法要慢得多。其中一些PPP已经得到了开发人员的确认，并根据我们的报告进行了修复。

我们的漏洞检测工作的**主要贡献**在于<u>证实了效率规则的存在和价值</u>：在我们的研究中，效率规则通常被多个开发人员在多个地方违反，并且有时出现在多个程序中。我们的经验促使未来的工作可以通过<u>新的补丁语言[43]、自动化补丁分析[36]、源代码分析或面向性能的注解来自动生成效率规则</u>。未来的工作还可以通过将静态检查与动态分析和工作负载监控相结合，提高性能漏洞检测的准确性。

##  2. Methodology

### 2.1 Applications

我们选择了五个开源软件套件进行研究：Apache、Chrome、GCC、Mozilla和MySQL。这些广受欢迎的、屡获奖项的软件套件[22]都是大规模且成熟的，拥有数百万行源代码和良好维护的缺陷数据库。

如表1所示，这五个套件涵盖了各种类型的软件，包括交互式GUI应用程序、服务器软件、命令行实用程序、编译器和库。它们主要使用C/C++和Java编写。虽然它们都是开源软件，但Chrome由Google支持，而MySQL则在2008年被Sun/Oracle收购。此外，Chrome浏览器于2008年首次发布，而其他四个软件已有10-15年的缺陷报告历史。从这些应用程序中，我们可以观察到传统和新的软件趋势，如Web应用程序。

![image-20230719163628018](../../../../Library/Application Support/typora-user-images/image-20230719163628018.png)

### 2.2 Bug Collection

GCC、Mozilla和MySQL的开发人员会使用特殊标签（compile-time-hog、perf和S5）在其<u>缺陷数据库</u>中明确标记某些报告为性能错误。而Apache和Chrome的开发人员则没有使用任何特殊标签来标记性能错误。因此，我们使用一组<u>与性能相关的关键词（如'slow'、 'performance'、 'latency'、 'throughput'等）搜索它们的缺陷数据库</u>。

### 2.3 Caveats（说明）

我们的研究结果需要在方法论的基础上进行理解。我们研究的应用程序涵盖了代表性和重要的软件类别、工作负载、开发背景和编程语言。当然，仍然有一些未涵盖的类别，例如科学计算软件和分布式系统。

我们的研究中的缺陷是从五个缺陷数据库中无偏倚地收集的。我们遵循开发人员关于何为性能错误的决策，并没有有意忽略任何缺陷数据库中性能问题的方面。当然，有些性能问题可能永远不会被报告到缺陷数据库，有些报告的问题可能永远不会被开发人员修复。不幸的是，我们无法研究这些未报告或未修复的性能问题。我们相信我们研究中的缺陷提供了这些代表性应用程序中报告和修复的性能错误的代表性样本。

我们花费了一年多的时间来研究与每个缺陷相关的所有信息，包括论坛讨论、补丁、源代码仓库等。每个缺陷至少由两个人进行研究，整个过程包括多轮缺陷再研究、缺陷再分类、交叉核查等步骤。

最后，我们并不强调任何定量的特征结果，我们发现的大多数特征在所有检测的应用程序中都是一致的。

## 3. Case Studies

我们的研究目标是通过<u>启发更好的技术</u>来提高软件效率，从而避免、暴露、检测和修复性能错误。本节将使用我们<u>缺陷集中的四个激励性示例</u>来展示我们研究的可行性和潜力。特别地，我们将使用这些示例回答以下问题：

（1）性能错误是否与传统错误在传统的错误处理过程（例如错误避免、测试、检测和修复）中有太大的不同？ 

（2）如果它们并不完全不同，它们是否过于相似，不值得进行研究？ 

（3）如果开发人员更加谨慎，我们是否仍需要研究和工具支持来解决性能错误？

**透明绘制（图2）**：Mozilla开发人员实现了一个过程nsImage::Draw，用于图形缩放、合成和渲染，这对于透明图形来说是浪费时间的。这个问题直到两年后才引起开发人员的注意，当时1像素乘1像素的透明GIF图像成为Web开发人员广泛用于解决HTML 4中某些特殊问题的通用间隔符。此错误的补丁在函数输入为透明图形时跳过nsImage::Draw函数的执行。

![image-20230719174157098](../../../../Library/Application Support/typora-user-images/image-20230719174157098.png)

**高强度垃圾回收（图3）**：用户报告称，在某些流行的网页（如gmail.com）上，Firefox消耗的CPU资源是Safari的10倍。经过长时间的性能分析和代码调查，发现Firefox在每个XMLHttpRequest结束时执行了一次昂贵的<u>垃圾回收过程GC</u>，而这次回收太频繁了。一位开发者回想起五年前为了解决XHR（XMLHttpRequest）不频繁、每次XHR替换JavaScript中大量DOM的情况而添加了GC。然而，现代Web页面已经发生了变化。作为促成Web 2.0的主要特性，XHR现在比五年前更常见。通过移除对GC的调用来修复了这个bug。



![image-20230720094540053](../../../../Library/Application Support/typora-user-images/image-20230720094540053.png)

**全部书签（图4）**：用户报告称，当他们在有20个打开的标签页时点击“全部书签（标签页）”时，Firefox会卡住。调查发现Firefox在添加N个标签页时使用了N个数据库事务，这与将所有书签任务批处理到单个事务中相比非常耗时。开发者之间的讨论揭示了Firefox的数据库服务库没有提供将任务聚合到一个事务中的接口，因为几年前Firefox几乎没有可批处理的数据库任务。而增加了类似“全部书签（标签页）”的批处理功能则暴露了这个低效率的问题。在用单个doAggregateTransact替换了N个doTransact的调用后，卡顿问题消失了。在修复审查期间，开发者发现了另外两个类似问题的地方，并通过doAggregateTransact修复了它们。

![image-20230720094845986](../../../../Library/Application Support/typora-user-images/image-20230720094845986.png)

**慢速快速锁（图5）**：MySQL同步库开发人员为了快速锁定实现了一个快速互斥锁。不幸的是，用户的单元测试显示，快速互斥锁比普通锁慢40倍。原来问题在于库函数random()实际上包含了一个锁。这个锁使得调用random()的每个线程都被串行化。开发者通过用非同步的随机数生成器替换random()来修复了这个bug。

![image-20230720095226883](../../../../Library/Application Support/typora-user-images/image-20230720095226883.png)

这四个漏洞可以帮助我们回答之前提出的问题。

**(1) 它们与传统错误有相似之处。**例如，它们都与函数/ API 的使用规则相关，这是以前关于检测功能错误的研究已经深入探讨过的主题 [30, 33]。

**(2) 它们与传统错误也存在有趣的差异。**例如，图2-4中的代码片段在编写后很长时间才出现错误（或变得更加错误），这对于功能错误来说是罕见的。另一个例子是，针对功能错误设计的测试无法有效地暴露类似“Bookmark All”这样的错误。一旦程序尝试过在一个或两个打开的标签上使用“bookmark all”按钮，再进行更多标签的书签化将不会改善语句或分支覆盖率，并且功能测试会跳过该部分。

**(3) 开发人员无法独自解决这些错误。**他们无法预测未来的工作负载或代码更改，以避免类似“Transparent Draw”、“Intensive GC”和“Bookmark All”这样的错误。即使是实现同步库的专家，也无法避免类似“Slow Fast-Lock”这样的错误，因为这些库使用了不透明的 API，具有意外的性能特性。在这方面需要研究和工具支持。当然，仅凭四个错误就得出任何结论是过早的。接下来，我们将全面研究109个性能错误。

## 4. Characteristics Study

我们将从性能错误的生命周期和不同的解决方法出发，研究真实世界性能错误的以下方面：

1. 性能错误的**根本原因**是什么？这项研究将提供对真实世界性能错误的基本理解，并为错误检测研究提供指导。
2. 性能错误是**如何引入**的？这项研究将揭示如何避免引入性能错误。
3. 性能错误**如何表现**出来？这项研究可以帮助设计有效的测试技术，在性能错误被引入到软件后将其暴露出来。
4. 性能错误**如何修复**？对这个问题的答案将有助于改进修补过程。

该研究的结果将在表2中呈现。

### 4.1 Root Causes of Performance Bugs

存在许多导致低效代码的潜在根本原因，例如设计不良的算法、非最优的数据结构、不友好的缓存数据布局等。我们在这里的目标不是发现以前未曾听闻的根本原因，而是检查真实世界性能错误中<u>是否存在常见的根本原因模式</u>，以便Bug检测可以集中关注。

**不协调的函数调用**：我们研究中超过<u>三分之一</u>的性能错误是由由<u>高效的单个函数组合而成的低效函数</u>调用组合引起的。这种情况可以在图4中的"Bookmark All"示例中看到。使用doTransact在一个数据库事务中添加一个URL的书签是高效的。然而，通过使用N个独立事务添加N个URL的书签，效率较低，相比之下，使用doAggregateTransact将所有URL的书签批量添加到一个事务中效率更高。

**可跳过的函数**：超过<u>四分之一</u>的错误是由于在调用上下文中<u>执行不必要的工作</u>而导致的，例如在“Transparent Draw”错误（图2）中为透明图形调用nsImage::Draw，以及在“Intensive GC”错误（图3）中调用不必要的GC操作。

**同步问题**：不必要的同步会<u>加剧线程竞争</u>，也是性能损失的常见原因，正如“Slow Fast-Lock”错误（图5）所示。这些错误在服务器应用程序中特别常见，其中有15个Apache服务器错误中的4个和26个MySQL服务器错误中的5个是由此引起的。

**其他原因**：剩下的23个错误是由<u>各种原因</u>引起的。有些使用了错误的<u>数据结构</u>。有些与<u>硬件架构</u>问题有关。有些是由<u>高级设计/算法问题</u>引起的，具有较长的传播链。例如，MySQL39295发生在MySQL错误地对只读查询使查询缓存无效的情况。这个操作本身并不耗时，但会导致后续的缓存未命中和性能损失。这种根本原因在GCC中特别常见。

### 4.2 How Performance Bugs Are Introduced

我们对bug数据库中开发者的讨论进行了研究，并检查了不同软件版本的源代码，以了解**错误是如何引入**的。我们的研究特别关注开发者在编写高效软件时面临的挑战，以及**影响引入性能错误的现代软件特性**。

<u>我们的研究显示开发人员急需工具帮助他们避免以下错误：</u>

**工作负载不匹配「Workload Mismatch」**：性能错误最常发生在开发人员的工作负载理解与实际情况不匹配时。

我们进一步的调查显示以下挑战是导致大部分**工作负载不匹配的原因**。

首先，<u>代码实现后输入范式可能会发生变化。</u>例如，HTML标准的改变和网页内容的新趋势导致了《透明绘制》和《密集垃圾回收》（见图2和图3）

其次，<u>软件工作负载相较以往变得更加多样化和复杂</u>。例如，像Mozilla这样的单个程序可能会面临多种类型的工作负载问题：网页上透明图像的普及导致了Figure 2中的“Transparent Draw”问题；大量使用XMLHttpRequest导致了Figure 3中的“Intensive GC”问题；用户习惯不更改默认配置设置导致了Mozilla Bug110555问题。

未来，现代软件日益动态和多样化的工作负载将导致更多的性能错误。

**API误解「API Misunderstanding」**：第二个最常见的原因是开发人员对某些函数的性能特性存在误解。在我们的研究中，有31个错误是由于这种原因导致的。

有时候，某个<u>函数的性能对特定参数的值非常敏感</u>，而开发人员恰巧使用了影响性能的数值。

有时，开发人员<u>使用一个函数来执行任务i，并且并不知道该函数内部同时执行了与性能无关的任务j</u>，这导致了性能下降但不影响功能。例如，MySQL开发人员不知道`random()`函数内部包含了同步操作，从而引入了Figure 5中的Slow Fast-Lock漏洞。

现代软件中的<u>代码封装</u>导致<u>许多API的性能特性文档不完善</u>。我们已经看到开发人员明确地对这个问题进行抱怨[51]。这将导致未来出现更多的性能错误。

**其他「Others」**：除了工作负载问题和API问题之外，性能错误背后还有其他原因。有趣的是，<u>一些性能错误是功能性错误的副作用</u>。例如，在Mozilla196994中，开发人员忘记重置一个忙碌标志。这个语义错误导致事件处理程序不断忙碌。因此，性能损失是这个错误唯一外部可见的症状。

**本来不应该是错误的错误「When a bug was not buggy」**：一个有趣的趋势是，109个bug中有29个最初并不是错误的。它们在很长一段时间后由于工作负载的变化（例如Transparent Draw和Intensive GC的情况，如图2和图3所示）或者软件其他部分的代码更改（例如图1中的情况）而变得低效。在Chrome70153中，当GPU加速器可用时，某些软件渲染代码变得低效。这些bug中有很多在回归测试中都没有被发现。

### 4.3 How Performance Bugs Are Exposed

我们将"暴露性能bug"定义为导致明显的性能负面影响，遵循大多数bug报告中使用的约定。

我们的研究展示了**性能测试**面临的几个**独特挑战**。

**总是活跃的错误「Always Active Bugs」**：非常可观的一部分性能错误几乎总是处于活跃状态。它们位于启动阶段、关闭阶段或其他几乎所有输入都会触发的位置。从长远来看，这些错误可能非常有害，因为它们在每次运行程序时都会在每个部署位置浪费性能。其中许多错误是通过与其他软件（例如Chrome与Mozilla与Safari的比较）进行对比而发现的。

在性能测试中，判断性能错误是否已经显现是一个独特的挑战。