# Learning from Mistakes — A Comprehensive Study on Real World Concurrency Bug Characteristic｜了解和检测真实世界的性能错误

## Abstract

1. 开发人员经常使用低效的代码序列，可以通过简单的补丁来修复性能错误。
2. 性能错误会导致严重的性能下降和资源浪费，在多核时代和能源效率的要求下需要更多的努力来解决性能错误。
3. 本文对来自Apache、Chrome、GCC、Mozilla和MySQL五个代表性软件套件的109个真实世界性能错误进行了全面的研究。
4. 通过特征研究，从25个补丁中提取了效率规则，并用于检测性能错误。
5. 在MySQL、Apache和Mozilla应用程序的最新版本中，发现了332个以前未知的性能问题，其中包括应用规则发现的219个跨应用程序的性能问题。

## 1.  Introduction

### 1.1 Motivation

**性能错误**称为**软件缺陷**，指的是<u>相对简单的源代码更改可以显著加快软件速度，同时保留功能</u>。这些缺陷无法通过现有的编译器进行优化，因此会影响最终用户。

* **发布的软件中普遍存在性能错误。**<u>性能错误的普遍存在是不可避免的，因为很少有工作帮助开发人员避免与性能相关的错误</u>。

* 会导致**现场的吞吐量降低、延迟增加和资源浪费**。

* **诊断这些问题是非常耗时的**
* 未来以下趋势将使性能错误问题变得更加紧迫：
  * 硬件：在多核时代，当每个核心不太可能变得更快时，性能错误尤为有害
  * 软件：软件系统的复杂性不断增加
  * 能源效率：经济理由

### 1.2 Contribution 1: Characteristics Study

* 对性能错误的理解和观念
* 避免错误
* 性能测试
* 错误检测
* 错误修复和检测
* 与功能性错误的比较

### 1.3  Contribution 2: Bug Detection

基于：<u>规则的错误检测</u>对于<u>检测功能错误</u> 是 有效的

推断：

1. 存在与效率相关的规则；
2. 我们可以从性能错误的补丁中提取规则；
3. 我们可以使用提取的规则来发现以前未知的性能错误

主要工作：

1. <u>25个Apache、Mozilla和MySQL的错误补丁</u>中收集了规则
2. 构建了<u>静态检查器</u>
3. 检查器发现的错误：
   * Apache、Mozilla和MySQL原始错误版本的<u>125个潜在的性能问题</u>（PPPs）
   * Apache、Mozilla和MySQL最新版本的<u>332个以前未知的潜在性能问题</u>（PPPs）
4. 彻底的代码审查和单元测试，验证这些PPPs确实降低了性能

工作贡献：

1. 证实了效率规则的存在和价值
2. 促使：新的补丁语言[43]、自动化补丁分析[36]、源代码分析或面向性能的注解 来 <u>自动生成效率规则</u>
3. 将静态检查与动态分析和工作负载监控相结合，提高性能漏洞检测的准确性

## 2. Methodology

### 2.1 Applications

研究软件：Apache、Chrome、GCC、Mozilla和MySQL（五个开源软件套件）

### 2.2 Bug Collection

GCC、Mozilla和MySQL的缺陷数据库中有性能缺陷标记，Apache和Chrome则没有。

因此，使用与性能相关的关键词（如'slow'、 'performance'、 'latency'、 'throughput'等）搜索它们的缺陷数据库。

### 2.3 Caveats（说明）

* 研究范围：
  * 研究的应用程序涵盖：代表性和重要的软件类别、工作负载、开发背景和编程语言。
  * 未涵盖的类别：科学计算软件和分布式系统。

* 数据内容：
  * 研究中的缺陷是从五个缺陷数据库中无偏倚地收集的。
  * 遵循开发人员关于何为性能错误的决策
  * 有些性能问题可能永远不会被报告到缺陷数据库，我们无法研究这些未报告或未修复的性能问题。
  * 我们相信我们研究中的缺陷提供了这些代表性应用程序中报告和修复的性能错误的代表性样本。

## 3. Case Studies

回答的问题：

1. 性能错误是否<u>与传统错误</u>在<u>传统的错误处理过程（例如错误避免、测试、检测和修复）</u>中有太大的不同？ 
2. 如果它们并不完全不同，它们是否过于<u>相似</u>，不值得进行研究？ 
3. 如果开发人员更加谨慎，我们<u>是否仍需要研究和工具</u>支持来解决性能错误？

使用的四个实例：

1. 透明绘制（图2）
2. 高强度垃圾回收（图3）
3. 全部书签（图4）
4. 慢速快速锁（图5）

得出回答：

1. 它们与传统错误有相似之处
2. 它们与传统错误也存在有趣的差异：在编写后很长时间才出现错误；无法有效地暴露类似“Bookmark All”这样的错误；等
3. 开发人员无法独自解决这些错误

## 4. Characteristics Study

1. 性能错误的**根本原因**是什么？这项研究将提供对真实世界性能错误的基本理解，并为错误检测研究提供指导。
2. 性能错误是**如何引入**的？这项研究将揭示如何避免引入性能错误。
3. 性能错误**如何表现**出来？这项研究可以帮助设计有效的测试技术，在性能错误被引入到软件后将其暴露出来。
4. 性能错误**如何修复**？对这个问题的答案将有助于改进修补过程。

### 4.1 Root Causes of Performance Bugs

**不协调的函数调用**：我们研究中超过<u>三分之一</u>的性能错误是由由<u>高效的单个函数组合而成的低效函数</u>调用组合引起的。

**可跳过的函数**：超过<u>四分之一</u>的错误是由于在调用上下文中<u>执行不必要的工作</u>而导致的。

**同步问题**：不必要的同步会<u>加剧线程竞争</u>，也是性能损失的常见原因。

### 4.2 How Performance Bugs Are Introduced

目标：

1. 了解**错误是如何引入**的
2. 研究在**编写高效软件时面临的挑战**，以及**影响引入性能错误的现代软件特性**。

错误原因：

1. （大部分原因）工作负载不匹配「Workload Mismatch」：
   * 代码实现后输入范式可能会发生变化
   * 软件工作负载相较以往变得更加多样化和复杂
2. API误解「API Misunderstanding」：
   * 函数的性能对特定参数的值非常敏感
   * 使用一个函数来执行任务i，并且并不知道该函数内部同时执行了与性能无关的任务j
   * 代码封装导致许多API的性能文档不完善
3. 其他「Others」：还有其他原因。发现：有些性能错误是功能错误的一个表征（副作用）
4. 本来不应该是错误的错误「When a bug was not buggy」：本来不是错误但是经过一段时间的工作负载变化或者软件其他地方的变化，而成为错误

### 4.3 How Performance Bugs Are Exposed

性能测试的独特挑战：

1. 总是活跃的错误「Always Active Bugs」：非常可观的一部分性能错误几乎总是处于活跃状态。它们位于启动阶段、关闭阶段或其他几乎所有输入都会触发的位置。从长远来看，这些错误可能非常有害，因为它们在每次运行程序时都会在每个部署位置浪费性能。其中许多错误是通过与其他软件（例如Chrome与Mozilla与Safari的比较）进行对比而发现的。
2. 



